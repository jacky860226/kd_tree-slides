<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>k-d tree</title>
		<meta name="description" content="KD-TREE">
		<meta name="author" content="SunMoon Master">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
		<link rel="stylesheet" href="reveal/css/reveal.css">
		<link rel="stylesheet" href="reveal/css/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/style.css"><!-- Code syntax highlighting -->
		<link rel="stylesheet" href="reveal/lib/css/zenburn.css">
		<!-- Printing and PDF exports --><script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal/css/print/pdf.css' : 'reveal/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script><!--[if lt IE 9]><script src="lib/js/html5shiv.js"></script><![endif]-->
	</head>
	<body>
	<div></div>
	<div class="reveal">
		<div class="slides">
			\( 
			  \newcommand{\ord}[1]{\mathcal{O}\left(#1\right)}
			  \newcommand{\abs}[1]{\lvert #1 \rvert}
			  \newcommand{\floor}[1]{\lfloor #1 \rfloor}
			  \newcommand{\ceil}[1]{\lceil #1 \rceil}
			  \newcommand{\opord}{\operatorname{\mathcal{O}}}
			  \newcommand{\argmax}{\operatorname{arg\,max}}
			  \newcommand{\str}[1]{\texttt{"#1"}}
			\)
			<!-- ... 這裡是註解文字 ... -->
			<section>
				<h1>K-D TREE</h1>
				<p><div class="small">南天門日月卦長</div></p>
			</section>
			<section>
				<section>
					<h2>什麼是K-D TREE</h2>
					<p class="fragment">
						k-d樹(k-維樹的縮寫)<br/>
						是在k維歐幾里德空間組織點的資料結構
					</p>
					<div class="fragment">
						比賽中常用來做範圍搜尋及最鄰近搜尋
					</div>
				</section>
			</section>
			<section>
				<h2>K-D TREE的基本操作</h2>
				這裡以計算曼哈頓距離的k-d tree作為範例
			</section>
			<section>
				<section>
					<h2>結構定義</h2>
				</section>
				<section data-markdown>
					<script type="text/template">
						首先要定義點，因為是多維的<br/>
						所以這裡用d[i]代表第i維的座標<br/>
						``` cpp
						#define kd 2
						#define T int
						struct point{
							T d[kd];//應用中通常是二維的
							inline T dist(const point &x)const{//傳回曼哈頓距離
								T ret=0;
								for(size_t i=0;i<kd;++i)ret+=std::abs(d[i]-x.d[i]);
								return ret;
							}
							inline bool operator==(const point &p){
								for(size_t i=0;i<kd;++i){
									if(d[i]!=p.d[i])return 0;
								}
								return 1;
							}
							inline bool operator<(const point &b)const{
								return d[0]<b.d[0];//這裡的小於不重要
							}
						};
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						之後要定義樹的節點
						``` cpp
						struct node{
							node *l,*r;
							point pid;
							int s;//節點大小
							node(const point &p):l(0),r(0),pid(p),s(1){}
							inline void up(){
								s=(l?l->s:0)+1+(r?r->s:0);
							}
						}*root;
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						定義比較第sort_id維的仿函數
						``` cpp
						struct __cmp{
							int sort_id;//優先比較的維度
							inline bool operator()(const node*x,const node*y)const{
								return operator()(x->pid,y->pid);
							}
							inline bool operator()(const point &x,const point &y)const{
								if(x.d[sort_id]!=y.d[sort_id])
									return x.d[sort_id]<y.d[sort_id];
								for(size_t i=0;i<kd;++i){
									if(x.d[i]!=y.d[i])return x.d[i]<y.d[i];
								}
								return 0;
							}
						}cmp;
						```
					</script>
				</section>
			</section>
			<section>
				<section>
					<h2>構造</h2>
				</section>
				<section>
					本質上來說，k-d tree是一種平衡二叉樹<p/>
					必須要理解的是，k-d tree是空間分割樹<br/>
					就是把整個空間劃分為特定幾個部分<br/>
					然後在特定空間進行相關操作
				</section>
				<section>
					k-d tree把一個二維空間的點集合<br/>
					按造一定規則劃分成多個空間<br/>
					(2,3), (5,4), (9,6), (4,7), (8,1), (7,2)<br/>
					<img src="img/370px-Kdtree_2d.png">
				</section>
				<section>
					建構出來的樹長這樣<br/>
					<img src="img/Tree_0001.png">
				</section>
				
				<section data-markdown>
					<script type="text/template">
						設kd為k-d tree的維度<br/>
						在建構第k層時，劃分的維度就會是第k % kd維<br/>
						找出A中對第k%kd維排序的中位數M <br/>
						並把小於M的point排在M左邊，大於M的排右邊<br/>
						``` cpp
						std::vector<node*> A;
						node* build(int k,int l,int r){
							if(l>r)return 0;
							if(k==kd)k=0;
							int mid=(l+r)/2;//分半讓樹保持平衡
							cmp.sort_id=k;//把優先比較的維度設為k
							std::nth_element(A.begin()+l,A.begin()+mid,A.begin()+r+1,cmp);
							node *ret=A[mid];
							ret->l=build(k+1,l,mid-1);
							ret->r=build(k+1,mid+1,r);
							ret->up();
							return ret;
						}
						inline void build(int n,const point *p){
							A.resize(n);
							for(int i=0;i<n;++i)A[i]=new node(p[i]);
							root=build(0,0,n-1);
						}
						```
					</script>
				</section>
				<section>
					<h2>複雜度</h2>
					<div class="theorem">
						因為樹是平衡的，所以深度為\(\ord{log \; n}\)<br/>
						每一層找中位數要花\(\ord n\)<br/>
						根據主定理可知構造一顆k-d tree的複雜度為<br/>
						$$\ord{n \; log \; n}$$
					</div>
				</section>
			</section>
			<section>
				<section>
					<h2>插入</h2>
				</section>
				<section data-markdown>
					<script type="text/template">
						很容易理解所以直接放上code
						``` cpp
						bool insert(node*&u,const point &x,int k=0){
							if(!u){
								u=new node(x);
								return true;
							}
							cmp.sort_id=k;
							if(insert(cmp(x,u->pid)?u->l:u->r,x,(k+1)%kd)){
								++u->s;
								return true;
							else return false;
						}
						```
					</script>
				</section>
				<section>
					<h2>複雜度</h2>
					<div class="theorem">
						複雜度很明顯就是\(\ord{樹的高度}\)<br/>
						所以最壞情況下可以是\(\ord n\)<p/>
						不過我們可以用替罪羊樹去平衡他<br/>
						可以達到\(\ord{log \; n*log \; n}\)的時間<p/>
						關於平衡的方法請參考:<br/>
						<a href="http://sunmoon-template.blogspot.tw/2016/02/dynamic-kd-tree-kd.html" target="_blank">日月卦長的模板庫-動態kd樹模板</a>
						<br/>
						不知道替罪羊樹的請參考:<br/>
						<a href="http://sunmoon-template.blogspot.tw/2015/02/scapegoat-tree.html" target="_blank">日月卦長的模板庫-替罪羊樹模板</a>
					</div>
				</section>
			</section>
			<section>
				<section>
					<h2>刪除</h2>
				</section>
				<section>
					用和一般二元搜尋樹一樣的刪除方法<br/>
					找到要刪除的點後<br/>
					找他右子樹中同一個分割維度最小的去取代他<br/>
					如果沒有右子樹就交換左右子樹再進行同樣的操作<br/>
					最後在遞迴刪除右子樹中被取代的點<br/>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						node *findmin(node*o,int k){
							if(!o)return 0; 
							if(cmp.sort_id==k)return o->l?findmin(o->l,(k+1)%kd):o;
							node *l=findmin(o->l,(k+1)%kd);
							node *r=findmin(o->r,(k+1)%kd);
							if(l&&!r)return cmp(l->pid,o->pid)?l:o;
							if(!l&&r)return cmp(r->pid,o->pid)?r:o;
							if(!l&&!r)return o;
							if(cmp(l->pid,r->pid))return cmp(l->pid,o->pid)?l:o;
							return cmp(r->pid,o->pid)?r:o;
						}
						bool erase(node *&u,const point &x,int k=0){
							if(!u)return 0;
							if(u->pid==x){
								if(u->r);
								else if(u->l){
									u->r=u->l;
									u->l=0;
								}else{
									delete u;
									u=0;
									return 1;
								}
								cmp.sort_id=k;
								u->pid=findmin(u->r,(k+1)%kd)->pid;
								return erase(u->r,u->pid,(k+1)%kd);
							}
							cmp.sort_id=k;
							return erase(cmp(x,u->pid)?u->l:u->r,x,(k+1)%kd);
						}
						```
					</script>
				</section>
				<section>
					<h2>複雜度</h2>
					<div class="theorem">
						設樹的深度為\(\ord{log_{\alpha}n}\)<br/>
						則findmin的最差複雜度為\(\ord{\alpha^{(kd-1)*(log_{\alpha}n)/kd}}=\ord{n^{1-1/kd}}\)<br/>
						因此刪除的最差複雜度為:<br/>
						$$\ord{n^{1-1/kd}+樹的高度}$$
						而且效能非常差
					</div>
				</section>
			</section>
			<section>
				<section>
					<h2>K近鄰算法</h2>
				</section>
				<section data-markdown class="theorem">
					<script type="text/template">
						K近鄰算法就是給定一個點p，必須要查找一個集合中離p第k近的點，明顯有以下的暴力解法
						``` cpp
						std::priority_queue<std::pair<T,point > >pQ;//用heap來維護前k近的距離
						int qM;//heap最多可以放幾個點
						void nearest(node *u,int k,const point &x,T &mndist){
							if(u==0)return;
							T dist=u->pid.dist(x);
							if(dist<mndist){
								pQ.push(std::make_pair(dist,u->pid));
								if((int)pQ.size()==qM+1){//超過點的數量就要pop
									mndist=pQ.top().first,pQ.pop();
								}
							}
							nearest(u->l,(k+1)%kd,x,mndist);
							nearest(u->r,(k+1)%kd,x,mndist);
						}
						inline T nearest(const point &x,int k){
							qM=k;
							T mndist=INF;
							nearest(root,0,x,mndist);
							mndist=pQ.top().first;
							pQ=std::priority_queue<std::pair<T,point > >();
							return mndist;/*回傳離x第k近的點的距離*/ 
						}
						```
					</script>
				</section>
				<section>
					<h2>啟發式搜索(感謝Morris提供的方法)</h2>
					<div class="theorem">
						類似於A*算法，我們可以提供一個heuristic值表示這顆子樹最少能查詢到的距離，若heuristic >= mndist則不進行走訪<br/>
						我們只要想辦法維護這個heuristic值就好了<br/>
						根據Morris的說法，在曼哈頓距離的情況下複雜度為\(\ord{log \; n}\)
					</div>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						std::priority_queue<std::pair<T,point > >pQ;//用heap來維護前k近的距離
						int qM;//heap最多可以放幾個點
						inline T heuristic(const T h[]){
							T ret=0;
							for(size_t i=0;i<kd;++i)ret+=h[i];
							return ret;
						}
						void nearest(node *u,int k,const point &x,T *h,T &mndist){
							if(u==0||heuristic(h)>=mndist)return;
							T dist=u->pid.dist(x),old=h[k];
							if(dist<mndist){
								pQ.push(std::make_pair(dist,u->pid));
								if((int)pQ.size()==qM+1){
									mndist=pQ.top().first,pQ.pop();
								}
							}
							/*
							查找左右子樹的順序很重要。如果x.d[k]<u->pid.d[k]
							表示u左子樹中的點其第k維距離x的第k維都比右子樹近
							應該先走訪左子樹，反之就要先走訪右子樹
							這樣能盡可能快速的找到答案
							*/
							if(x.d[k]<u->pid.d[k]){
								nearest(u->l,(k+1)%kd,x,h,mndist);
								h[k]=abs(x.d[k]-u->pid.d[k]);//維護heuristic的值
								nearest(u->r,(k+1)%kd,x,h,mndist);
							}else{
								nearest(u->r,(k+1)%kd,x,h,mndist);
								h[k]=abs(x.d[k]-u->pid.d[k]);//維護heuristic的值
								nearest(u->l,(k+1)%kd,x,h,mndist);
							}
							h[k]=old;//最後記得把heuristic改回原本的狀態
						}
						inline T nearest(const point &x,int k){
							qM=k;
							T mndist=INF,h[kd]={};//heuristic初始化是0
							nearest(root,0,x,h,mndist);
							mndist=pQ.top().first;
							pQ=std::priority_queue<std::pair<T,point > >();
							return mndist;/*回傳離x第k近的點的距離*/ 
						}
						```
					</script>
				</section>
				<section>
					<h2>另一種作法</h2>
					<div class="theorem">
						從root節點開始，DFS搜索直到葉子節點，同時在stack中順序存儲已經訪問的節點。<br/>
						如果搜索到葉子節點，當前的葉子節點被設為最近鄰節點。<br/>
						然後通過stack回溯:<br/>
						如果當前點的距離比最近鄰點距離近，更新最近鄰節點.<br/>
						然後檢查以最近距離為半徑的圓是否和父節點的超平面相交.<br/>
						如果相交，則必須到父節點的另外一側，用同樣的DFS搜索法，開始檢查最近鄰節點。<br/>
						如果不相交，則繼續往上回溯，而父節點的另一側子節點都被淘汰，不再考慮的範圍中.<br/>
						當搜索回到root節點時，搜索完成，得到最近鄰節點。
					</div>
				</section>
				<section>
					<h2>複雜度</h2>
					不管用甚麼方法最差情況還是會搜索到\(\ord{n^{1-1/kd}}\)個點<br/>
					所以最差複雜度是\(\ord{n^{1-1/kd}}\)
				</section>
			</section>
			<!--結束了-->
		</div>
	</div>
	<script src="js/jquery.js"></script>
	<script src="reveal/lib/js/head.min.js"></script>
	<script src="reveal/js/reveal.js"></script>
	<script src="js/sketch.min.js"></script>
	<script>// Full list of configuration options available at:
	// https://github.com/hakimel/reveal.js#configuration
	Reveal.initialize({
	  controls: true,
	  progress: true,
	  history: true,
	  center: true,
	  //-showNotes: true,

	  transition: 'slide', // none/fade/slide/convex/concave/zoom

	  // Optional reveal.js plugins
	  dependencies: [
		{ src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
		{ src: 'reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
		{ src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
		{ src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
		{ src: 'reveal/plugin/zoom-js/zoom.js', async: true },
		{ src: 'reveal/plugin/notes/notes.js', async: true },
		{ src: 'reveal/plugin/math/math.js', async: true, callback: function() {
		  setTimeout( function() {
			MathJax.Hub.Config({
			  SVG: {
				scale: 90
				},
			  "HTML-CSS": {
				scale: 90,
				}
			  });
			}, 2000);
		  },
		  config: 'TeX-AMS_HTML-full'
		},
		{ src: 'js/dazzleSketch.js', async: true }
	  ]
	});</script>
	</body>
</html>